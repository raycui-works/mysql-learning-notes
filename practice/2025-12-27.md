- 演过电影的演员有多少人？
```sql
-- COUNT()必须这么写，函数字母和括号中间不能有空格
-- COUNT(*):统计所有行数（包含NULL值）
-- COUTN(film_id):统计行数（该列不包含NULL值的行数；坑：有NULL值的行，COUNT(*)会将其统计为1，得出完全错误的结果）
-- GROUP BY a.actor_id:只是把这些行“按 actor_id 分堆”,按谁分堆(桶里装的仍然是 JOIN 后整行数据，不仅仅是 actor 表字段。)
-- COUNT(fa.film_id):是在“每个桶里数 film_id”(NULL值计为0)；如果是COUNT(*),则会把NULL值计为1
-- HAVING:对“分组（GROUP BY）之后的结果”进行筛选。

SELECT COUNT(*) AS actors_with_films
FROM (
      SELECT a.actor_id
      FROM actor a
      LEFT JOIN film_actor fa
           ON a.actor_id = fa.actor_id
      GROUP BY a.actor_id
      HAVING COUNT(fa.film_id) > 0
     ) t;
```

- 没演过电影的演员有多少人？
```sql
SELECT COUNT(*) AS actors_without_films
FROM (
      SELECT a.actor_id
      FROM actor a
      LEFT JOIN film_actor fa 
           ON a.actor_id = fa.actor_id
      GROUP BY a.actor_id
      HAVING COUNT(fa.film_id) = 0
     ) t;
```
>一句话总结（记住就不会乱）
>
>GROUP BY：我按“谁”汇总（actor）
>COUNT：我在每个“谁”的范围内统计“什么”（film_id）
>
>你按“人”汇总，当然可以统计“他相关的电影数量”。
>
>⸻
>
>类比（更直觉）
>
>把 actor_id 当成“班级”，film_id 当成“作业本”：
>	•	GROUP BY 班级：按班级分堆
>	•	COUNT(作业本)：每个班交了几本作业
>
>分组字段决定“分堆依据”，统计字段决定“堆里数啥”。
>⸻
>HAVING vs WHERE（最关键的区别）
>WHERE
>	•	分组之前筛选“原始行”
>	•	不能用聚合结果（不能在这里写 COUNT()、SUM() 等）
>	•	更快（先过滤再分组，数据量更小）
>HAVING
>	•	分组之后筛选“组（汇总行）”
>	•	可以用聚合结果（COUNT/SUM/AVG/MAX/MIN）
>	•	用于“只保留满足统计条件的组”
>一句话记忆：
>
>WHERE 过滤行，HAVING 过滤组。
>HAVING 和其他关键词的关系（执行顺序视角）
>⸻
>数据库执行顺序大致是：
>
>FROM → JOIN → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT
>
>所以你可以理解为：
>	•	WHERE：在“统计前”就把不需要的行丢掉
>	•	GROUP BY：把行按某个字段分堆汇总
>	•	HAVING：在“统计后”再把不符合条件的组丢掉
>	•	ORDER BY：对最终结果排序
>	•	LIMIT：截取前 N 行
